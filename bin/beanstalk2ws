#!/usr/bin/env ruby

require 'json'
require 'em-websocket'
require 'em-jack'

# plugin must be loaded first!
require 'sequel'
Sequel::Model.plugin :json_serializer
require_relative '../model/init'
require_relative '../options'

TCC::Log.level = Log4r.const_get(TCC.options.log_level)

module TCC
  class RibbonWebSocket < EM::WebSocket::Connection
    def self.start(options, &block)
      EM.epoll?
      @fsr_socket = options.delete :fsr_socket

      EM.run do
        EM.start_server(options[:host], options[:port], self, options, &block)
      end
    end

    def trigger_on_message(message)
      Log.debug "Message: %p" % {message: message}
      raw = JSON.parse(message)
      frame, body = raw.values_at('frame', 'body')
      url, method, id, attr =
        body.values_at('url', 'method', 'id', 'attributes')

      bbm = "backbone_#{method}"
      if url == 'Agent'
        say frame: frame, ok: __send__(bbm, id, attr)
      else
        raise 'Unknown url %p in %p' % [url, raw]
      end

    rescue => ex
      Log.error(ex)
      say frame: frame, error: ex.to_s
    end

    def say(obj)
      Log.debug say: obj
      send(obj.to_json)
    end

    EXPOSE = [
      :id, :first_name, :last_name, :registration_server,
      :username, :extension
    ]

    def backbone_read(id, attributes)
      Log.debug read: {id: id, attributes: attributes}

      if id
        account = Account[id: id]
      else
        ext = attributes['extension']
        account = Account[extension: ext]
        agent_connected(account)
      end

      raise 'no account found' unless account
      JSON.parse(account.to_json(only: EXPOSE))
    end

    def agent_connected(account)
      FSR.load_all_commands
      fsr = FSR::CommandSocket.new(server: TCC.options.command_server)
      cmd = fsr.call_center(:agent).set(account.agent, :status, 'Available')
      Log.debug cmd.raw
      Log.debug cmd.run
    end

    def channel_type(channel)
      channel.to_s.split("_",2)
    end

    def backbone_create(*args)
      channel, json = args
      channel, message = channel_type channel
      Log.debug "#{message.capitalize} #{channel}" => json
    end

    def backbone_update(*args)
      channel, json = args
      channel, message = channel_type channel
      Log.debug "#{message.capitalize} #{channel}" => json
    end

    def backbone_delete(*args)
      channel, json = args
      channel, message = channel_type channel
      Log.debug "#{message.capitalize} #{channel}" => json
    end
  end

  class JackTube < EMJack::Connection
    def process_job(ribbon, channel, json)
      case channel.to_s
      when /insert/
        ribbon.backbone_create(channel, json)
      when /update/
        ribbon.backbone_update(channel, json)
      when /delete/
        ribbon.backbone_delete(channel, json)
      end
    end

    def process_jobs(ribbon)
      each_job do |job|
        channel, json = job.body.split("\t",2)
        json = JSON.parse json
        delete(job).callback do
          process_job(ribbon, channel, json)
          TCC::Log.debug "deleted #{{channel => json}}"
        end
      end
    end

    def watch_socket(tube, ribbon)
      watch(tube).callback do |_tube|
        TCC::Log.info "Jack is listening on #{_tube}"
        process_jobs(ribbon)
      end
    end
  end
end

EM.run do
  # use the faster one, we don't care about the binary part
  host = '0.0.0.0'
  port = 43443
  TCC::Log.info "Starting Websocket on #{host}:#{port}"
  TCC::RibbonWebSocket.start(host: host, port: port, debug: false) do |ribbon|
    TCC.options.beanstalk.listen_tubes.each do |tube|
      TCC::Log.info "Starting JackTube for #{tube}"
      TCC::JackTube.new.watch_socket(tube, ribbon)
    end
  end
end
