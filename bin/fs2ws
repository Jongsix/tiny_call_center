#!/usr/bin/env ruby

require 'pp'
require 'cgi'
require 'json'
require 'csv'
require 'time'

require 'fsr'
require "fsr/listener/inbound"
require "fsr/command_socket"
FSR.load_all_commands
require 'em-websocket'
require_relative '../model/init'
require_relative '../options'

FSR::Log.level = Logger::DEBUG

module TinyCallCenter

  module ChannelRelay
    def relay(content)
      # FSR::Log.debug "Channel << %p" % [content]
      WebSocketReporter::Channel << content
    end
  end

  class QueueReporter < FSR::Listener::Inbound
    include ChannelRelay
    def before_session
      add_event(:CUSTOM, "callcenter::info", &method(:callcenter_info))
    end

    def callcenter_info(event)
      content = Hash[event.content.map{|k,v| [k, CGI.unescape(v)] }]
      return if content[:cc_action] == 'cc_queue_count'

      content.reject!{|k,v|
        k !~ /^(cc|event)_/ ||
        k =~ /^event_(subclass|name|date_local|calling_file|calling_function|calling_line_number)$/
      }

      FSR::Log.debug "received callcenter_info event #{content}"
      relay content
    end

    def callcenter
      @callcenter ||= FSR::Cmd::CallCenter.new(nil, :agent)
    end

    def callcenter!
      yield callcenter
      FSR::Log.info callcenter.raw
      api callcenter.raw
    end

  end

  class Monitor < FSR::Listener::Inbound
    include ChannelRelay

    def initialize(*args, &callback)
      @channel_answers = {}
      @channel_originates = {}
      super
    end

    def before_session
      [ :CHANNEL_ORIGINATE, # Call being placed/ringing
        :CHANNEL_ANSWER,    # Call starts
        :CHANNEL_HANGUP,    # Call ends
      ].each{|flag| add_event(flag, &method(flag.to_s.downcase)) }
    end

    def channel_originate(event)
      cont, uuid = event.content, event.content[:unique_id]
      FSR::Log.debug "Call Origniated: %s => %s (%s) (%s)" % [cont[:caller_caller_id_number], cont[:caller_destination_number], uuid, cont[:other_leg_unique_id]]
      FSR::Log.info cont.inspect

      clean_event = cleanup_msg(cont)
      @channel_originates[uuid] = clean_event
      @channel_originates[cont[:other_leg_unique_id]] = clean_event
      try_call_dispatch(uuid, cont[:other_leg_unique_id])
    end

    def channel_answer(event)
      content = event.content

      FSR::Log.debug "Call answered: %s <%s> => %s (%s)" % [
        content[:caller_caller_id_number],
        content[:caller_caller_id_name],
        content[:caller_destination_number],
        content[:unique_id],
      ]

      @channel_answers[content[:unique_id]] = cleanup_msg(content)
      try_call_dispatch(content[:unique_id])
    end

    def channel_hangup(event)
      content = event.content

      FSR::Log.debug "Call hungup: %s <%s> => %s (%s)" % [
        content[:caller_caller_id_number],
        content[:caller_caller_id_name],
        content[:caller_destination_number],
        content[:unique_id],
      ]

      relay cleanup_msg(content)
    end

    def cleanup_msg(content)
      msg = content.reject do |key, value|
        key =~ /^variable_/
      end

      msg.values.each do |value|
        value.replace(CGI.unescape(value.to_str)) if value.respond_to?(:to_str)
      end

      msg
    end

    def dispatch_call(left, right, originate)
      msg = {
        left_cid_number:   left[:caller_caller_id_number],
        right_cid_number: right[:caller_caller_id_number],

        left_destination:   left[:caller_destination_number],
        right_destination: right[:caller_destination_number],

        right_cid_name: right[:caller_caller_id_name],
        left_cid_name:   left[:caller_caller_id_name],

        left_channel:   left[:caller_channel_name],
        right_channel: right[:caller_channel_name],

        left_uuid:   left[:unique_id],
        right_uuid: right[:unique_id],

        call_created: originate[:event_date_gmt],
        queue_name: originate[:cc_queue],
      }

      FSR::Log.debug "Dispatching call #{msg}"
      message_agent msg.merge(tiny_action: 'call_start')
    end

    def try_call_dispatch(left, right = nil)
      # If we're an originate, check for both answers
      if right
        return unless left_answer = @channel_answers[left]
        return unless right_answer = @channel_answers[right]
        originate = @channel_originates[left]
        dispatch_call(left_answer, right_answer, originate) if left_answer and right_answer
      elsif left_answer = @channel_answers[left]
        return unless originate = @channel_originates[left]
        if left == originate[:other_leg_unique_id]
          return unless right_answer = @channel_answers[originate[:unique_id]]
        else
          return unless right_answer = @channel_answers[originate[:other_leg_unique_id]]
        end
        dispatch_call(left_answer, right_answer, originate) if left_answer and right_answer
      end
    end

    def possible_numbers(message)
      message.values_at(
        :left_destination, :right_destination,
        :left_cid_number, :right_cid_number
      ).compact
    end

    def message_agent(message)
      relay message # for Channel

      keys = [
        message[:cc_agent].to_s.split('-').first,
        *possible_numbers(message)
      ].compact

      agent = keys.find{|key| WebSocketReporter::SubscribedAgents[key] }
      agent.got_fs_event(message)
    end
  end

  class WebSocketReporter < Struct.new(:reporter, :user, :socket, :command_socket_server, :channel_id, :agent, :listen)
    Channel = EM::Channel.new
    SubscribedAgents = {}

    STATUS_MAPPING = {
      'available' => 'Available',
      'available_on_demand' => 'Available (On Demand)',
      'on_break' => 'On Break',
      'logged_out' => 'Logged Out',
    }

    def initialize(reporter, socket, command_socket_server)
      self.reporter, self.socket = reporter, socket
      self.command_socket_server = command_socket_server

      socket.onopen(&method(:on_open))
      socket.onmessage(&method(:on_message))
      socket.onclose(&method(:on_close))
    end

    def agent_listing
      sock = fsr_socket(self.command_socket_server)
      agents = sock.call_center(:agent).list.run
      sock.socket.close
      agents
    end

    def fsr_socket(server)
      FSR::CommandSocket.new(:server => server)
    end

    def on_open
    end

    def prepare_message(message)
    end

    private

    def my_message?(message)
      FSR::Log.debug("#{agent} in my_message? for #{message}")

      return false unless agent
      return true if message[:cc_agent] == agent
      return false if message[:cc_agent]

      FSR::Log.debug("#{agent} still in my_message? for #{message}")

      extension = agent.split("-").first
      numbers = possible_numbers(message)
      return true if numbers.include?(extension)

      FSR::Log.debug("#{agent} FAILED in my_message? for #{message}")
      return false
    end

    def can_view?(message)
      FSR::Log.debug("#{agent} Asking for access to #{message}")

      return false unless agent

      self.user ||= TinyCallCenter::Account.from_call_center_name(agent)
      return false unless user && user.extension

      if cc = message[:cc_agent]
        extension = cc.split("-")[0].tr("_", "")
        FSR::Log.debug("#{user} has user extension #{user.extension} and extension #{extension} cc is #{cc}")
        return true if cc == agent
        return user.extension == extension || user.can_view?(extension)
      end

      numbers = possible_numbers(message)
      unless numbers.size > 1
        FSR::Log.warn("#{agent} Asking for access to crazysauce: #{message}")
        return true
      end

      FSR::Log.debug("#{agent} Asking for access to #{numbers}")
      return true if numbers.detect{|number| number.size == 4 && user.can_view?(number) }

      FSR::Log.debug("#{agent} DENIED access to: #{numbers}")
      false
    end

    public
    def on_message(json)
      msg = JSON.parse(json)

      case msg['method']
      when 'subscribe' ; got_subscribe(msg)
      when 'listen'    ; got_listen(msg)
      when 'status_of' ; got_status_of(msg)
      when 'status'    ; got_status(msg)
      when 'calltap'   ; got_calltap(msg)
      when 'calltaptoo'; got_calltap_too(msg)
      else
        FSR::Log.warn "Unknown message: %p" % [msg]
      end
    rescue JSON::ParserError => ex
      FSR::Log.error ex
    end

    def got_subscribe(msg)
      self.agent = msg['agent']
      FSR::Log.info "Subscribed agent: #{self.agent}"
      reporter.callcenter!{|cc| cc.set(self.agent, :status, 'Available') }

      @extension = self.agent.split('-', 2).first

      SubscribedAgents[@extension] = self

      fsock = FSR::CommandSocket.new server: Account.registration_server(@extension)
      calls = fsock.channels(true).run

      stat = agent_status(@extension, calls).merge(tiny_action: :initial_status)
      send stat
    end

    def got_fs_event(msg)
      send msg
    end

    def got_listen(msg)
      self.agent = msg['agent']
      self.listen = true
      FSR::Log.info "Subscribing listener: #{self.agent}"

      self.user = TinyCallCenter::Account.from_call_center_name(agent) # everything regarding perms in Account
      FSR::Log.info "User #{user} subscribed"

      agents = agent_listing
      if user.manager?
        agents.select! {|_agent| user.can_view?(_agent.extension) }
        FSR::Log.info "#{user} can view #{agents.size} agents"
      else
        # if somehow an agent got here, just show them themselves
        FSR::Log.info "User #{user} not a manager, showing just self"
        agents.select! {|_agent| self.agent == _agent.name }
      end

      servers = {}
      registrars = agents.map {|_agent| _agent.to_hash["contact"].split("@")[1] }.uniq
      registrars.each do |r|
        fsock = FSR::CommandSocket.new server: r
        servers[r] = fsock.channels(true).run
        fsock.socket.close
        fsock = nil
      end

      utimes = %w[last_bridge_start last_offered_call last_bridge_end last_status_change]
      agents.map!{|_agent|
        agent_ext = _agent.name.split('-').first
        agent_server = _agent.contact.to_s.split('@')[1]
        agent_calls = servers[agent_server]
        _agent = _agent.to_hash.merge(agent_status(agent_ext, agent_calls))
        utimes.each{|key|
          _agent[key] = Time.at(_agent[key].to_i).rfc2822
        }
        _agent
      }

      send agents: agents
    end

    def agent_status(extension, calls)
      return {} unless extension && calls

      sip = /sip:#{extension}@/
      return {} unless found = calls.find do |call|
        [call.dest, call.callee_cid_num, call.caller_cid_num].include?(extension) ||
        [call.caller_chan_name, call.callee_chan_name].any?{|name| name =~ sip }
      end

      stat = if found.dest
        # got an FSR::Channel here
        {
          caller_cid_num:     found.cid_num,
          caller_cid_name:    found.cid_name,
          caller_dest_num:    found.dest,
          callee_cid_num:     found.dest,
          uuid:               found.uuid,
          call_created:       Time.at(found.created_epoch.to_i).rfc2822,
        }
      else
        # Assume an FSR::Call here
        {
          caller_cid_num:     found.caller_cid_num,
          caller_cid_name:    found.caller_cid_name,
          caller_dest_num:    found.caller_dest_num,
          callee_cid_num:     found.callee_cid_num,
          uuid:               found.call_uuid,
          call_created:       Time.at(found.call_created_epoch.to_i).rfc2822,
        }
      end
      FSR::Log.debug "Sending agent status: #{stat}"
      stat
    end

    def got_status_of(msg)
      mapped = STATUS_MAPPING[msg['status']]
      agent = msg['agent']
      reporter.callcenter!{|cc| cc.set(agent, :status, mapped) }
    end

    def got_status(msg)
      FSR::Log.debug "Status Change: #{msg}"
      current, new = msg.values_at('curStatus', 'status')
      mapped = STATUS_MAPPING[new]
      if current == mapped or mapped == @_last_status
        FSR::Log.warn "Got a dupe #{self.agent}: #{msg}"
        return false
      end
      @_last_status = mapped
      reporter.callcenter!{|cc| cc.set(self.agent, :status, mapped) }
    end

    def got_calltap_too(msg)
      extension, name, tapper, uuid, phoneNumber = msg.values_at('extension', 'name', 'tapper', 'uuid', 'phoneNumber')
      if manager = TinyCallCenter::Account.from_call_center_name(tapper)
        return false unless manager.manager?
        return false unless agent = TinyCallCenter::Account.from_full_name(name)
        if manager.manager.authorized_to_listen?(extension, phoneNumber)
          eavesdrop(uuid, agent, manager)
        end
      end
    end

    def  eavesdrop(uuid, agent, tapper)
      return false unless agent.registration_server
      FSR::Log.info("Tapping #{agent.full_name} at #{agent.registration_server}: #{uuid}")
      if (sock = FSR::CommandSocket.new(:server => agent.registration_server) rescue nil)
        if eavesdrop_extension = tapper.manager.eavesdrop_extension
          cmd = sock.originate(:target => eavesdrop_extension, :endpoint => "&eavesdrop(#{uuid})")
        elsif tapper.registration_server == agent.registration_server
          cmd = sock.originate(:target => "user/#{tapper.extension}", :endpoint => "&eavesdrop(#{uuid})")
        else
          cmd = sock.originate(:target => "sofia/internal/#{tapper.extension}@#{tapper.registration_server}", :endpoint => "&eavesdrop(#{uuid})")
        end
        FSR::Log.info("Tap Command %s" % cmd.raw)
        p cmd.run
      end
    end
    private :eavesdrop

    def got_calltap(msg)
      agent, tapper = msg.values_at('agent', 'tapper').map { |a| TinyCallCenter::Account.new(a.split("-",2)[1].gsub("_","")) }
      return false unless agent.exists? and tapper.exists?
      return false unless tapper.manager?
      if (sock = FSR::CommandSocket.new(:server => agent.registration_server) rescue nil)
        res = sock.say("api hash select/#{agent.registration_server}-spymap/#{agent.extension}")
        if uuid = res["body"]
          eavesdrop(uuid, agent, tapper)
        end
      end
    end

    def on_close
      Channel.unsubscribe(channel_id)
      SubscribedAgents.delete(@extension)

      if listen
        FSR::Log.debug "Unsubscribed listener: #{agent}"
      else
        FSR::Log.debug "Unsubscribed agent: #{agent}"
      end
    end

    def send(obj)
      socket.send(obj.to_json)
    end
  end
end

EM.epoll?
# Need to make all of these env vars
command_socket_server = TinyCallCenter.options.command_server
port = TinyCallCenter.options.fs_port.to_i
auth = TinyCallCenter.options.fs_auth
EM.run do
  TinyCallCenter.options.registration_servers.each do |monitor_server|
    EventMachine.connect(monitor_server, port, TinyCallCenter::Monitor, host: monitor_server, port: port, auth: auth, output_format: 'plain')
  end

  EventMachine.connect(command_socket_server, port, TinyCallCenter::QueueReporter, host: command_socket_server, port: port, auth: auth, output_format: 'plain') do |reporter|
    EventMachine.start_server('0.0.0.0', 8080, EventMachine::WebSocket::Connection, {}) do |websocket|
      TinyCallCenter::WebSocketReporter.new(reporter, websocket, command_socket_server)
    end
  end
end
