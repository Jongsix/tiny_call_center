#!/usr/bin/env ruby

require 'sequel'
require 'pgpass'
require 'socket'
require 'eventmachine'

channels = ARGV
if channels.empty?
  warn "No Channels Specified, falling back to defaults"
  channels = %w[channel call agent tier member].map{|prefix|
    %w[insert update delete].map{|suffix|
      "#{prefix}_#{suffix}" }}.flatten
end

url = Pgpass.match(database: 'freeswitch').to_url
DB = Sequel.connect(url)

warn "connected to pg: %p (%p)" % [url, DB]
warn "listening on %p" % [channels]

class RubyClient < EM::Connection
  attr_reader :connected
  include EM::P::ObjectProtocol
  def connection_completed
    warn "Connection Established to #{@host}:#{@port}."
    @connected = true
  end

  def initialize(args={})
    super
    @host = args[:host] || 'localhost'
    @port = args[:port] || 43442
    @connected = false
  end

  def unbind
    @connected = false
    warn "Disconnected from #{@host}:#{@port}, reconnecting"
    EM.add_timer(1) { reconnect @host, @port }
  end
end

EM.run do
  port = 43442
  host = 'localhost'

  EM.connect(host, port, RubyClient, host: host, port: port) do |client|
    listener = lambda do |channel, pid, payload|
      begin
        msg = "#{channel}\t#{payload}"
        timer = EM::PeriodicTimer.new(0.1) do
          next unless client.connected
          warn msg
          res = client.send_object(channel: channel, msg: payload)
          timer.cancel unless res == -1
        end
      rescue Exception => ex
        warn ex
      ensure
        $stdout.flush
      end
    end

    listening = lambda do
      DB.listen(channels, &listener)
      EM.defer(&listening)
    end

    EM.defer(&listening)
  end
end
