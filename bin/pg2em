#!/usr/bin/env ruby

require 'sequel'
require 'pgpass'
require 'socket'
require 'eventmachine'

channels = ARGV
if channels.empty?
  warn "No Channels Specified, falling back to defaults"
  channels = %w[channel call agent tier member].map{|prefix|
    %w[insert update delete].map{|suffix|
      "#{prefix}_#{suffix}" }}.flatten
end

url = Pgpass.match(database: 'freeswitch').to_url
DB = Sequel.connect(url)

warn "connected to pg: %p (%p)" % [url, DB]
warn "listening on %p" % [channels]

class RubyClient < EM::Connection
  include EM::P::ObjectProtocol

  attr_reader :connected

  def initialize(args={})
    super
    @host = args[:host] || 'localhost'
    @port = args[:port] || 43442
    @connected = false
    @queue = EM::Queue.new

    EM.defer{ handle_queue }
  end

  def connection_completed
    warn "Connection Established to #{@host}:#{@port}."
    @connected = true
  end

  def unbind
    @connected = false
    warn "Disconnected from #{@host}:#{@port}, reconnecting"
    EM.add_timer(0.5){ reconnect @host, @port }
  end

  def deliver(message)
    @queue.push message
  end

  NOT_GIVEN = Object.new

  def handle_queue(message = NOT_GIVEN)
    if message == NOT_GIVEN
      @queue.pop do |message|
        handle_queue(message)
      end
    else
      if send_object(message) > 1
        EM.defer{ handle_queue }
      else
        EM.add_timer(0.1){ handle_queue(message) }
      end
    end
  end
end

EM.run do
  port = 43442
  host = 'localhost'

  Thread.abort_on_exception = true

  EM.connect(host, port, RubyClient, host: host, port: port) do |client|
    EM.defer do
      DB.send :check_database_errors do
        DB.synchronize do |conn|
          channels.each{|chan| conn.execute("LISTEN #{chan}") }

          check = lambda do
            conn.wait_for_notify 1 do |channel, pid, payload|
              p channel => payload
              client.deliver c: channel, b: payload
            end

            EM.defer(&check)
          end

          check.call
        end
      end
    end
  end
end
