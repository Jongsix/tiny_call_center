#!/usr/bin/env ruby

require 'sequel'
require 'pgpass'
require 'socket'
require 'eventmachine'

channels = ARGV
if channels.empty?
  warn "No Channels Specified, falling back to defaults"
  channels = %w[channel call agent tier member].map{|prefix|
    %w[insert update delete].map{|suffix|
      "#{prefix}_#{suffix}" }}.flatten
end

url = Pgpass.match(database: 'freeswitch').to_url
DB = Sequel.connect(url)

warn "connected to pg: %p (%p)" % [url, DB]
warn "listening on %p" % [channels]

class RubyClient < EM::Connection
  attr_reader :connected
  include EM::P::ObjectProtocol
  def connection_completed
    warn "Connection Established to #{@host}:#{@port}."
    @connected = true
  end

  def initialize(args={})
    super
    @host = args[:host] || 'localhost'
    @port = args[:port] || 43442
    @connected = false
  end

  def unbind
    @connected = false
    warn "Disconnected from #{@host}:#{@port}, reconnecting"
    EM.add_timer(1) { reconnect @host, @port }
  end
end

EM.run do
  port = 43442
  host = 'localhost'
  queue = []
  EM.connect(host, port, RubyClient, host: host, port: port) do |client|
    timer = EM::PeriodicTimer.new(1) do
      next unless client.connected
      next if queue.size == 0
      warn "Sending #{queue.size} queued messages"
      (0 .. queue.size-1).each do |i|
        channel, payload = queue.shift
        msg = "#{channel}\t#{payload}"
        warn msg
        res = client.send_object(channel: channel, msg: payload)
        unless res > 0
          warn "Re-adding to queue: #{msg}"
          queue.unshift [channel, payload]
          break
        end
        warn "Sent: #{res}"
      end
    end

    listener = lambda do |channel, pid, payload|
      begin
        msg = "#{channel}\t#{payload}"
        unless client.connected
          warn "Not connected, added to queue: #{msg}"
          queue << [channel, payload]
          warn queue
        else
          warn msg
          res = client.send_object(channel: channel, msg: payload)
          queue << [channel, payload] unless res > 1
        end
      rescue Exception => ex
        warn ex
      ensure
        $stdout.flush
      end
    end

    listening = lambda do
      DB.listen(channels, &listener)
      EM.defer(&listening)
    end

    EM.defer(&listening)
  end
end
